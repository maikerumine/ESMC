/**
    Copyright (C) 2017 by jabelar

    This file is part of jabelar's Minecraft Forge modding examples; as such,
    you can redistribute it and/or modify it under the terms of the GNU
    General Public License as published by the Free Software Foundation,
    either version 3 of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    For a copy of the GNU General Public License see <http://www.gnu.org/licenses/>.
*/

package com.maikerumine.ESMC.utilities;

import java.util.List;

import com.maikerumine.ESMC.Main;
import com.maikerumine.ESMC.entity.IModEntity;
import com.maikerumine.ESMC.init.ModNetworking;
import com.maikerumine.ESMC.networking.MessageSyncEntityToClient;
import com.maikerumine.ESMC.networking.MessageSyncEntityToServer;

import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.item.Item;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.world.World;
import net.minecraftforge.fml.client.FMLClientHandler;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

// TODO: Auto-generated Javadoc
/**
 * @author jabelar
 *
 */
public class Utilities
{
    
    /**
     * This allows you to add fancy formatting to the mod info displayed in the mod list.
     *
     * @param event the new mod info
     */
    public static void setModInfo(FMLPreInitializationEvent event)
    {
        // hard-code mod information so don't need mcmod.info file
        event.getModMetadata().autogenerated = false; // stops it from complaining about missing mcmod.info
        event.getModMetadata().credits = TextFormatting.BLUE + Main.MODCREDITS;
        event.getModMetadata().authorList.add(TextFormatting.RED + Main.MODAUTHOR);
        event.getModMetadata().description = TextFormatting.YELLOW + Main.MODDESCRIPTION;
        event.getModMetadata().url = Main.MODURL;
        event.getModMetadata().logoFile = Main.MODLOGO;
    }

    // Need to call this on item instance prior to registering the item
    /**
     * Sets the item name.
     *
     * @param parItem
     *            the par item
     * @param parItemName
     *            the par item name
     * @return the item
     */
    // chainable
    public static Item setItemName(Item parItem, String parItemName)
    {
        parItem.setRegistryName(parItemName);
        parItem.func_77655_b(parItemName);
        return parItem;
    }

    // Need to call this on block instance prior to registering the block
    /**
     * Sets the block name.
     *
     * @param parBlock
     *            the par block
     * @param parBlockName
     *            the par block name
     * @return the block
     */
    // chainable
    public static Block setBlockName(Block parBlock, String parBlockName)
    {
        parBlock.setRegistryName(parBlockName);
        parBlock.func_149663_c(parBlockName);
        return parBlock;
    }

    /*
     * Text Utilities
     */

    /**
     * String to rainbow.
     *
     * @param parString
     *            the par string
     * @param parReturnToBlack
     *            the par return to black
     * @return the string
     */
    public static String stringToRainbow(String parString, boolean parReturnToBlack)
    {
        int stringLength = parString.length();
        if (stringLength < 1)
        {
            return "";
        }
        String outputString = "";
        TextFormatting[] colorChar = {
                TextFormatting.RED,
                TextFormatting.GOLD,
                TextFormatting.YELLOW,
                TextFormatting.GREEN,
                TextFormatting.AQUA,
                TextFormatting.BLUE,
                TextFormatting.LIGHT_PURPLE,
                TextFormatting.DARK_PURPLE
        };
        for (int i = 0; i < stringLength; i++)
        {
            outputString = outputString + colorChar[i % 8] + parString.substring(i, i + 1);
        }
        // return color to a common one after (most chat is white, but for other GUI might want black)
        if (parReturnToBlack)
        {
            return outputString + TextFormatting.BLACK;
        }
        return outputString + TextFormatting.WHITE;
    }

    /**
     * String to rainbow.
     *
     * @param parString
     *            the par string
     * @return the string
     */
    // by default return to white (for chat formatting).
    public static String stringToRainbow(String parString)
    {
        return stringToRainbow(parString, false);
    }

    /**
     * String to golden.
     *
     * @param parString
     *            the par string
     * @param parShineLocation
     *            the par shine location
     * @param parReturnToBlack
     *            the par return to black
     * @return the string
     */
    public static String stringToGolden(String parString, int parShineLocation, boolean parReturnToBlack)
    {
        int stringLength = parString.length();
        if (stringLength < 1)
        {
            return "";
        }
        String outputString = "";
        for (int i = 0; i < stringLength; i++)
        {
            if ((i + parShineLocation + Minecraft.func_71386_F() / 20) % 88 == 0)
            {
                outputString = outputString + TextFormatting.WHITE + parString.substring(i, i + 1);
            }
            else if ((i + parShineLocation + Minecraft.func_71386_F() / 20) % 88 == 1)
            {
                outputString = outputString + TextFormatting.YELLOW + parString.substring(i, i + 1);
            }
            else if ((i + parShineLocation + Minecraft.func_71386_F() / 20) % 88 == 87)
            {
                outputString = outputString + TextFormatting.YELLOW + parString.substring(i, i + 1);
            }
            else
            {
                outputString = outputString + TextFormatting.GOLD + parString.substring(i, i + 1);
            }
        }
        // return color to a common one after (most chat is white, but for other GUI might want black)
        if (parReturnToBlack)
        {
            return outputString + TextFormatting.BLACK;
        }
        return outputString + TextFormatting.WHITE;
    }

    /**
     * String to golden.
     *
     * @param parString
     *            the par string
     * @param parShineLocation
     *            the par shine location
     * @return the string
     */
    // by default return to white (for chat formatting).
    public static String stringToGolden(String parString, int parShineLocation)
    {
        return stringToGolden(parString, parShineLocation, false);
    }

    /**
     * Based on code from http://pages.cs.wisc.edu/~ltorrey/cs302/examples/PigLatinTranslator.java Method to translate a sentence word by word.
     * 
     * @param s
     *            The sentence in English
     * @return The pig latin version
     */
    public static String toPigLatin(String s)
    {
        String latin = "";
        int i = 0;
        while (i < s.length())
        {
            // Take care of punctuation and spaces
            while (i < s.length() && !isLetter(s.charAt(i)))
            {
                latin = latin + s.charAt(i);
                i++;
            }

            // If there aren't any words left, stop.
            if (i >= s.length())
                break;

            // Otherwise we're at the beginning of a word.
            int begin = i;
            while (i < s.length() && isLetter(s.charAt(i)))
            {
                i++;
            }

            // Now we're at the end of a word, so translate it.
            int end = i;
            latin = latin + pigWord(s.substring(begin, end));
        }
        return latin;
    }

    /**
     * Method to test whether a character is a letter or not.
     * 
     * @param c
     *            The character to test
     * @return True if it's a letter
     */
    private static boolean isLetter(char c)
    {
        return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
    }

    /**
     * Method to translate one word into pig latin.
     * 
     * @param word
     *            The word in english
     * @return The pig latin version
     */
    private static String pigWord(String word)
    {
        int split = firstVowel(word);
        return word.substring(split) + "-" + word.substring(0, split) + "ay";
    }

    /**
     * Method to find the index of the first vowel in a word.
     * 
     * @param word
     *            The word to search
     * @return The index of the first vowel
     */
    private static int firstVowel(String word)
    {
        word = word.toLowerCase();
        for (int i = 0; i < word.length(); i++)
        {
            if (word.charAt(i) == 'a' || word.charAt(i) == 'e' ||
                    word.charAt(i) == 'i' || word.charAt(i) == 'o' ||
                    word.charAt(i) == 'u')
            {
                return i;
            }
        }
        return 0;
    }

    /*
     * Networking packet utilities
     */

    /**
     * Send entity sync packet to client.
     *
     * @param parEntity
     *            the par entity
     */
    public static void sendEntitySyncPacketToClient(IModEntity parEntity)
    {
        Entity theEntity = (Entity) parEntity;
        if (!theEntity.func_130014_f_().field_72995_K)
        {
            // DEBUG
            System.out.println("sendEntitySyncPacket from server for entity ID =" + theEntity.func_145782_y());
            ModNetworking.network.sendToAll(new MessageSyncEntityToClient(theEntity.func_145782_y(), parEntity.getSyncDataCompound()));
        }
    }

    /**
     * Send entity sync packet to server.
     *
     * @param parEntity
     *            the par entity
     */
    public static void sendEntitySyncPacketToServer(IModEntity parEntity)
    {
        Entity theEntity = (Entity) parEntity;
        if (theEntity.func_130014_f_().field_72995_K)
        {
            // DEBUG
            System.out.println("sendEntitySyncPacket from client");
            ModNetworking.network.sendToServer(new MessageSyncEntityToServer(theEntity.func_145782_y(), parEntity.getSyncDataCompound()));
        }
    }

    /*
     * World utilities
     */

    /**
     * Finds the topmost block position at an X, Z position in the world.
     *
     * @param parWorld
     *            the par world
     * @param parX
     *            the par X
     * @param parZ
     *            the par Z
     * @return the height value
     */
    public static double getHeightValue(World parWorld, double parX, double parZ)
    {
        int intX = MathHelper.func_76128_c(parX);
        int intZ = MathHelper.func_76128_c(parZ);

        int chunkX = intX >> 4;
        int chunkZ = intZ >> 4;
        double height = parWorld.func_72964_e(chunkX, chunkZ)
                .func_76611_b(intX & 15, intZ & 15);

        return height;
    }

    /**
     * Gets the mouse over extended.
     *
     * @param dist
     *            the dist
     * @return the mouse over extended
     */
    // This is mostly copied from the EntityRenderer#getMouseOver() method
    public static RayTraceResult getMouseOverExtended(float dist)
    {
        Minecraft mc = FMLClientHandler.instance().getClient();
        Entity theRenderViewEntity = mc.func_175606_aa();
        AxisAlignedBB theViewBoundingBox = new AxisAlignedBB(
                theRenderViewEntity.field_70165_t - 0.5D,
                theRenderViewEntity.field_70163_u - 0.0D,
                theRenderViewEntity.field_70161_v - 0.5D,
                theRenderViewEntity.field_70165_t + 0.5D,
                theRenderViewEntity.field_70163_u + 1.5D,
                theRenderViewEntity.field_70161_v + 0.5D);
        RayTraceResult returnMOP = null;
        if (mc.field_71441_e != null)
        {
            double var2 = dist;
            returnMOP = theRenderViewEntity.func_174822_a(var2, 0);
            double calcdist = var2;
            Vec3d pos = theRenderViewEntity.func_174824_e(0);
            var2 = calcdist;
            if (returnMOP != null)
            {
                calcdist = returnMOP.field_72307_f.func_72438_d(pos);
            }

            Vec3d lookvec = theRenderViewEntity.func_70676_i(0);
            Vec3d var8 = pos.func_72441_c(lookvec.field_72450_a * var2, lookvec.field_72448_b * var2, lookvec.field_72449_c * var2);
            Entity pointedEntity = null;
            float var9 = 1.0F;
            List<Entity> list = mc.field_71441_e.func_72839_b(theRenderViewEntity,
                    theViewBoundingBox.func_72314_b(lookvec.field_72450_a * var2, lookvec.field_72448_b * var2, lookvec.field_72449_c * var2).func_72321_a(var9, var9, var9));
            double d = calcdist;

            for (Entity entity : list)
            {
                if (entity.func_70067_L())
                {
                    float bordersize = entity.func_70111_Y();
                    AxisAlignedBB aabb = new AxisAlignedBB(entity.field_70165_t - entity.field_70130_N / 2, entity.field_70163_u, entity.field_70161_v - entity.field_70130_N / 2,
                            entity.field_70165_t + entity.field_70130_N / 2, entity.field_70163_u + entity.field_70131_O, entity.field_70161_v + entity.field_70130_N / 2);
                    aabb.func_72321_a(bordersize, bordersize, bordersize);
                    RayTraceResult mop0 = aabb.func_72327_a(pos, var8);

                    if (aabb.func_72318_a(pos))
                    {
                        if (0.0D < d || d == 0.0D)
                        {
                            pointedEntity = entity;
                            d = 0.0D;
                        }
                    }
                    else if (mop0 != null)
                    {
                        double d1 = pos.func_72438_d(mop0.field_72307_f);

                        if (d1 < d || d == 0.0D)
                        {
                            pointedEntity = entity;
                            d = d1;
                        }
                    }
                }
            }

            if (pointedEntity != null && (d < calcdist || returnMOP == null))
            {
                returnMOP = new RayTraceResult(pointedEntity);
            }

        }
        return returnMOP;
    }
}
